#pragma version >=0.2.0;

#include "utils/constants.func";
#include "utils/op-codes.func";
#include "utils/helpers.func";



int __test_bridge_burn_notification_not_minter() {

    slice admin_address = set_test_bridge_conf();

	int query_id = rand( 12345 ) + 1;
	int burn_amount = one_unit;
    ;; Looking up
    var (int gas_init, stack) = invoke_method(get_bridge_data, []);

    cell minter_code = stack.third();
    cell wallet_code = stack.fourth();

	;; Making sure that source address would be valid jetton address
    cell content   = test_minter_content();

	slice sender   = generate_internal_address_with_custom_data(0, 0, random());
    (slice src, _) = test_calculate_minter_address(content, wallet_code, minter_code);
    slice  bad_src = src.generate_different_addr();

     {-
      This is what usually comming to the jetton-minter and then forwarded to bridge.
      When doing so, minter content is attached as a ref cell
    -}


    slice eth_dst = generate_eth_addr();
	var msg_body  = generate_bridge_burn_notification( query_id, burn_amount, sender, my_address(), eth_dst).store_ref(content);
    var body_sc   = msg_body.end_cell().begin_parse();

	cell msg      = generate_internal_message_custom(0, 0, 0, msg_body, bad_src, null(), 0);

    ;; Non-minter address should fail
	(int gas_fail ) = invoke_method_expect_fail(recv_internal, [one_unit, one_unit, msg, body_sc]);

    ;; New message with correct src should succeed
    msg                   = generate_internal_message_custom(0, 0, 0, msg_body, src, null(), 0);
	(int gas_success, _ ) = invoke_method(recv_internal, [one_unit, one_unit, msg, body_sc]);

    return gas_init + gas_fail + gas_success;

}

int __test_bridge_burn_notification_success() {

    slice admin_address = set_test_bridge_conf();

	int query_id    = rand( 12345 ) + 1;
	int burn_amount = one_unit;
    ;; Looking up
    var (int gas_init, stack) = invoke_method(get_bridge_data, []);

    cell minter_code = stack.third();
    cell wallet_code = stack.fourth();

	;; Making sure that source address would be valid jetton address
    cell content   = test_minter_content();

	slice sender   = generate_internal_address_with_custom_data(0, 0, random());
    (slice src, _) = test_calculate_minter_address(content, wallet_code, minter_code);

     {-
      This is what usually comming to the jetton-minter and then forwarded to bridge.
      When doing so, minter content is attached as a ref cell
    -}


    slice eth_dst = generate_eth_addr();
	var msg_body  = generate_bridge_burn_notification(query_id, burn_amount, sender, my_address(), eth_dst).store_ref(content);

	cell msg      = generate_internal_message_custom(0, 0, 0, msg_body, src, null(), 0);

	(int gas_used, _) = invoke_method( recv_internal, [one_unit, one_unit, msg, msg_body.end_cell().begin_parse()]);

    tuple actions = parse_c5();

    ;; Expect excess and log messages
    throw_if(300, actions.null?());
    ;; No more excess message
    throw_unless(301, actions.tuple_length() == 1);

    {-
    ;; Testing that action is a message and message mode is 2
    tuple excess = actions.first();
    throw_unless(302, excess.first()  == 0);
    throw_unless(303, excess.third()  == 2);

    ;; Testing excess message body values
    excess.second().verify_bridge_excess(400, query_id, my_address(), one_unit);
    -}

    tuple log = actions.first();
    throw_unless(500, log.first() == 0);
    throw_unless(500, log.third() == 0);

    log.second().assert_log_message(600, 0xc0470ccf, eth_dst.preload_uint(160), burn_amount, test_token_addr, sender);

    return gas_init + gas_used;
}

int __test_bridge_voting_not_oracle() {

    set_test_bridge_conf();

	int query_id = rand( 12345 ) + 1;

    slice oracle_addr = generate_internal_address_with_custom_data(0, -1, test_oracle_addr);
    slice not_oracle  = oracle_addr.generate_different_addr();

    var (int gas_init, stack) = invoke_method(get_bridge_data, []);

    cell minter_code = stack.third();
    cell wallet_code = stack.fourth();

    int addr_hash    = random();
    int mint_amount  = (rand(10) + 1) * one_unit;
    int fwd          = one_unit * (rand(10) + 1);

    {-
    var vote_req     = generate_bridge_voting_swap(query_id, random(),
                                                   rand(1 << 16),
                                                   addr_hash, mint_amount,
                                                   content, fwd);
    var vote_sc      = vote_req.end_cell().begin_parse();

    ;; Should fail since source is not oracle
    cell msg         = generate_internal_message_custom(0, 0, 0, vote_req, not_oracle, null(), 0);
    -}

    int gas_fail       = send_execute_voting(query_id, one_unit, addr_hash, mint_amount, fwd, not_oracle, true);

    int gas_success    = send_execute_voting(query_id, one_unit, addr_hash, mint_amount, fwd, oracle_addr, false);

    return gas_init + gas_fail + gas_success;
}

int __test_bridge_exec_swap_low_fee() {

    set_test_bridge_conf();

    var (int gas_init, stack) = invoke_method(get_bridge_data, []);

    cell minter_code = stack.third();
    cell wallet_code = stack.fourth();


    int addr_hash    = random();
    int query_id     = rand(12345) + 1;
    int mint_amount  = (rand(10) + 1) * one_unit;
    int fwd          = 0; ;; one_unit * (rand(10) + 1);

    slice oracle     = generate_internal_address_with_custom_data(0, -1, test_oracle_addr);

    int gas_vote     = send_execute_voting(query_id, one_unit, addr_hash, mint_amount, fwd, oracle, false);

    assert_vote_resp(300, query_id, oracle);

    int msg_val     = rand(test_bridge_mint_fee);
    int gas_fail    = send_execute_swap(query_id, msg_val, oracle, true);

    int gas_success = send_execute_swap(query_id, test_bridge_mint_fee, oracle, false);

    return gas_init + gas_vote + gas_fail + gas_success;

}

int __test_bridge_exec_swap_no_forward() {

    ;; Enough for mint fee but not enough for forward coins amount
    set_test_bridge_conf();

    var (int gas_init, stack) = invoke_method(get_bridge_data, []);

    cell minter_code = stack.third();
    cell wallet_code = stack.fourth();


    int addr_hash    = random();
    int query_id     = rand(12345) + 1;
    int mint_amount  = (rand(10) + 1) * one_unit;
    int fwd          = one_unit * (rand(10) + 1);
    int msg_val      = rand(fwd - test_bridge_mint_fee) + test_bridge_mint_fee; ;; < fwd + test_bridge_mint_fee

    slice oracle     = generate_internal_address_with_custom_data(0, -1, test_oracle_addr);

    int gas_vote     = send_execute_voting(query_id, one_unit, addr_hash, mint_amount, fwd, oracle, false);

    int gas_fail     = send_execute_swap(query_id, msg_val, oracle, true);

    int gas_success  = send_execute_swap(query_id, fwd + test_bridge_mint_fee, oracle, false);


    return gas_init + gas_vote + gas_fail + gas_success;
}

int __test_bridge_mint_success() {
    set_test_bridge_conf();

    var (int gas_init, stack) = invoke_method(get_bridge_data, []);

    cell minter_code = stack.third();
    cell wallet_code = stack.fourth();
    cell content     = test_minter_content();

    int addr_hash    = random();
    int query_id     = rand(12345) + 1;
    int mint_amount  = (rand(10) + 1) * one_unit;
    int fwd          = one_unit * (rand(10) + 1);

    slice oracle     = generate_internal_address_with_custom_data(0, -1, test_oracle_addr);

    int gas_vote     = send_execute_voting(query_id, one_unit, addr_hash, mint_amount, fwd, oracle, false);
    assert_vote_resp(300, query_id, oracle);

    int gas_exec     = send_execute_swap(query_id, fwd + test_bridge_mint_fee, oracle, false);

    tuple actions    = parse_c5();
    throw_if(300, actions.null?());
    throw_unless(301, actions.tuple_length() == 1);

    tuple mint = actions.first();
    throw_unless(302, mint.first() == 0);
    throw_unless(303, mint.third() == 64);

    tuple parsed = mint.second().parse_internal_message().unsafe_tuple();

    var (slice to_addr, mint_init) =  test_calculate_minter_address(content, wallet_code, minter_code);

    throw_unless(304, equal_slices(to_addr, parsed.at(4)));
    throw_unless(305, 0 == parsed.at(5));

    ;; Checking mint message
    var bs = parsed.at(8);
    throw_unless(306, op::mint() == bs~load_uint(32));
    throw_unless(307, query_id   == bs~load_uint(64));

    slice wallet_addr = generate_internal_address_with_custom_data(0, 0, addr_hash);
    throw_unless(308, equal_slices(wallet_addr, bs~load_msg_addr()));
    throw_unless(309, mint_amount == bs~load_grams());
    throw_unless(310, fwd         == bs~load_grams());

    return gas_init + gas_vote + gas_exec;
}
